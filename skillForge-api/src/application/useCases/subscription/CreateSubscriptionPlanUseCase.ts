import { injectable, inject } from 'inversify';
import { TYPES } from '../../../infrastructure/di/types';
import { ISubscriptionPlanRepository } from '../../../domain/repositories/ISubscriptionPlanRepository';
import { IUserRepository } from '../../../domain/repositories/IUserRepository';
import { IFeatureRepository } from '../../../domain/repositories/IFeatureRepository';
import { SubscriptionPlan } from '../../../domain/entities/SubscriptionPlan';
import { CreateSubscriptionPlanDTO } from '../../dto/subscription/CreateSubscriptionPlanDTO';
import { ForbiddenError, ConflictError, NotFoundError } from '../../../domain/errors/AppError';
import { UserRole } from '../../../domain/enums/UserRole';
import { ERROR_MESSAGES } from '../../../config/messages';
import { ICreateSubscriptionPlanUseCase } from './interfaces/ICreateSubscriptionPlanUseCase';
import { SubscriptionPlanDTO } from '../../dto/subscription/SubscriptionPlanDTO';
import { ISubscriptionPlanMapper } from '../../mappers/interfaces/ISubscriptionPlanMapper';

@injectable()
export class CreateSubscriptionPlanUseCase implements ICreateSubscriptionPlanUseCase {
  constructor(
    @inject(TYPES.IUserRepository) private userRepository: IUserRepository,
    @inject(TYPES.ISubscriptionPlanRepository) private subscriptionPlanRepository: ISubscriptionPlanRepository,
    @inject(TYPES.IFeatureRepository) private featureRepository: IFeatureRepository,
    @inject(TYPES.ISubscriptionPlanMapper) private subscriptionPlanMapper: ISubscriptionPlanMapper
  ) { }

  async execute(adminUserId: string, dto: CreateSubscriptionPlanDTO): Promise<SubscriptionPlanDTO> {
    // Verify admin privileges
    const adminUser = await this.userRepository.findById(adminUserId);
    if (!adminUser || adminUser.role !== UserRole.ADMIN) {
      throw new ForbiddenError(ERROR_MESSAGES.ADMIN.ACCESS_REQUIRED);
    }

    // Check if plan name already exists
    const existingPlan = await this.subscriptionPlanRepository.findByName(dto.name);
    if (existingPlan) {
      throw new ConflictError('A subscription plan with this name already exists');
    }

    // Create domain entity (features will be empty initially)
    const plan = new SubscriptionPlan(
      '', // ID will be generated by database
      dto.name,
      dto.price,
      dto.projectPosts ?? null,
      dto.createCommunity ?? null,
      [], // Empty features array, features created separately
      dto.badge as any,
      dto.color,
      true, // isActive
      new Date(),
      new Date(),
      dto.trialDays ?? 0
    );

    // Save to repository (creates the plan)
    const createdPlan = await this.subscriptionPlanRepository.create(plan);

    // Create features for this plan
    if (dto.features && dto.features.length > 0) {
      // Import Feature and FeatureType dynamically or ensure they are imported at top
      // Assuming imports are present or will be added
      const { Feature } = await import('../../../domain/entities/Feature');
      const { v4: uuidv4 } = await import('uuid');

      const featurePromises = dto.features.map(async (featureDto) => {
        const feature = new Feature({
          id: uuidv4(),
          planId: createdPlan.id, // Link to the new plan
          name: featureDto.name,
          description: featureDto.description,
          featureType: featureDto.featureType as any,
          limitValue: featureDto.limitValue,
          isEnabled: featureDto.isEnabled,
          displayOrder: featureDto.displayOrder,
          isHighlighted: featureDto.isHighlighted,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        return this.featureRepository.create(feature);
      });

      await Promise.all(featurePromises);
    }

    // Fetch the complete plan with features to return
    const completePlan = await this.subscriptionPlanRepository.findById(createdPlan.id);
    if (!completePlan) {
      throw new Error('Failed to retrieve created plan');
    }

    return this.subscriptionPlanMapper.toDTO(completePlan);
  }
}
